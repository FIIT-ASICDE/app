model Repo {
  id                   String                 @id @default(uuid()) @db.Uuid
  name                 String
  description          String?
  public               Boolean
  userOrganizationRepo RepoUserOrganization[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model RepoUserOrganization {
  favorite       Boolean
  pinned 		 Boolean?
  userMetadataId String        @db.Uuid
  userMetadata   UserMetadata  @relation(fields: [userMetadataId], references: [id])
  organizationId String?       @db.Uuid
  organization   Organization? @relation(fields: [organizationId], references: [id])
  repoId         String        @db.Uuid
  repo           Repo          @relation(fields: [repoId], references: [id])
  repoRole       RepoRole      @default(OWNER)
  lastVisitedAt  DateTime      @default(now())

  // user can have one role per repo, but it doesn't make sense to create
  // and PK from the unique columns, because searching through this table
  // will is done by joining either from user, org, or repo, not all
  @@unique([userMetadataId, repoId])
  @@index([userMetadataId])
  @@index([organizationId])
  @@index([repoId])
}

enum RepoRole {
  ADMIN
  CONTRIBUTOR
  VIEWER
  OWNER
}
